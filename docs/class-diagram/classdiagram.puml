@startuml Ricardo Auth Spring Boot Starter - Class Diagram

!define SPOTLESS_THEME
!theme sketchy-outline
skinparam backgroundColor #FEFEFE
skinparam classBackgroundColor #F8F9FA
skinparam classBorderColor #6C757D
skinparam arrowColor #495057
skinparam noteBackgroundColor #E8F4FD
skinparam noteBorderColor #2C5282
skinparam noteFontColor #1A202C
skinparam noteFontStyle bold
skinparam padding 10
skinparam classFontSize 11
skinparam packageFontSize 12

title Ricardo Auth Spring Boot Starter\nArchitecture Overview (v3.0.0)

!define DIRECTION left to right

package "Domain Layer" <<Rectangle>> {
    
    interface "AuthUser<R>" as AuthUser {
        +getId(): ID
        +getEmail(): String
        +setEmail(email: String): void
        +getUsername(): String
        +setUsername(username: String): void
        +getPassword(): String
        +setPassword(hashedPassword: String): void
        +getRoles(): Set<R>
        +addRole(role: R): void
        +removeRole(role: R): void
        +getAuthorities(): Collection<GrantedAuthority>
    }
    
    class User {
        -id: UUID
        -version: Long
        -username: Username
        -email: Email
        -password: Password
        -roles: Set<AppRole>
        -createdAt: Instant
        -updatedAt: Instant
        +User(username: Username, email: Email, password: Password)
        +isAccountNonExpired(): boolean
        +isAccountNonLocked(): boolean
        +isCredentialsNonExpired(): boolean
        +isEnabled(): boolean
    }
    
    class Username {
        -username: String
        +valueOf(username: String): Username
        +getUsername(): String
        -validateUsername(username: String): void
    }
    
    class Email {
        -email: String
        +valueOf(email: String): Email
        +getEmail(): String
        -validateEmail(email: String): void
    }
    
    class Password {
        -hashed: String
        +valueOf(raw: String, encoder: PasswordEncoder): Password
        +fromHash(hashedPassword: String): Password
        +getHashed(): String
        +matches(raw: String, encoder: PasswordEncoder): boolean
    }
    
    enum AppRole {
        USER
        ADMIN
        VIP
        +getAuthority(): String
    }
    
    class RefreshToken {
        -id: Long
        -token: String
        -userEmail: String
        -expiryDate: Instant
        -createdAt: Instant
        +RefreshToken(token: String, userEmail: String, expiryDate: Instant)
        +isExpired(): boolean
        +verifyExpiration(): RefreshToken
    }
    
    class RefreshTokenRequest {
        -refreshToken: String
        +RefreshTokenRequest(refreshToken: String)
        +getRefreshToken(): String
    }
    
    User .up.|> AuthUser
    User *-- Username : contains
    User *-- Email : contains
    User *-- Password : contains
    User o-- AppRole : has many
}

package "Core Interfaces" <<Rectangle>> {

    interface "UserService<U, R, ID>" as UserService {
        +createUser(user: U): U
        +getUserById(id: ID): U
        +getUserByEmail(email: String): U
        +getUserByUsername(username: String): U
        +emailExists(email: String): boolean
        +usernameExists(username: String): boolean
        +updateUser(id: ID, user: U): U
        +deleteUser(id: ID): void
        +getAllUsers(): List<U>
    }

    interface JwtService {
        +generateAccessToken(subject: String, authorities: Collection<GrantedAuthority>): String
        +extractSubject(token: String): String
        +extractRoles(token: String): List<String>
        +isTokenValid(token: String): boolean
        +isTokenValid(token: String, email: String): boolean
    }

    interface PasswordPolicyService {
        +validatePassword(password: String): boolean
        +generateSecurePassword(): String
    }

    interface AuthenticatedUser {
        +getEmail(): String
        +getRoles(): List<String>
    }

    interface "RefreshTokenService<U, ID>" as RefreshTokenService {
        +createRefreshToken(user: U): RefreshToken
        +findByToken(token: String): Optional<RefreshToken>
        +verifyExpiration(token: RefreshToken): RefreshToken
        +deleteByToken(token: String): void
        +deleteAllByUserEmail(userEmail: String): void
    }
}


package "Repository Layer" <<Rectangle>> {
    
    interface "UserRepository<U, R, ID>" as UserRepository {
        +findByEmail(email: String): Optional<U>
        +existsByEmail(email: String): boolean
        +deleteById(id: ID): void
    }
    
    interface "UserJpaRepository<U, R, ID>" as UserJpaRepository {
        +findByEmail_Email(email: String): Optional<U>
        +findByUsername_Username(username: String): Optional<U>
        +existsByEmail_Email(email: String): boolean
        +existsByUsername_Username(username: String): boolean
    }
    
    interface DefaultUserJpaRepository {
        ' Inherits from UserJpaRepository<DefaultUser, Role, UUID>
    }
    
    ' NEW: PostgreSQL Native Repository
    class "UserPostgreSQLRepository<U, R, ID>" as UserPostgreSQLRepository {
        -jdbcTemplate: JdbcTemplate
        -userRowMapper: UserRowMapper<U>
        -userSqlParameterMapper: UserSqlParameterMapper<U>
        -idConverter: IdConverter<ID>
        +findByEmail(email: String): Optional<U>
        +existsByEmail(email: String): boolean
        +save(user: U): U
        +deleteById(id: ID): void
        +findById(id: ID): Optional<U>
    }
    
    ' NEW: Refresh Token Repository Architecture
    interface RefreshTokenRepository {
        +saveToken(refreshToken: RefreshToken): RefreshToken
        +findByTokenRaw(token: String): Optional<RefreshToken>
        +findByToken(token: String): Optional<RefreshToken>
        +deleteExpiredTokens(): void
        +revokeAllUserTokens(userEmail: String): void
        +count(): long
    }
    
    interface JpaRefreshTokenRepository {
        +findByTokenRaw(token: String): Optional<RefreshToken>
        +deleteByExpiryDateBefore(date: Instant): void
        +deleteByUserEmail(userEmail: String): void
        +findByUserEmailOrderByCreatedAtDesc(userEmail: String): List<RefreshToken>
        +countByUserEmail(userEmail: String): long
    }
    
    interface DefaultJpaRefreshTokenRepository {
        ' Inherits from JpaRefreshTokenRepository
    }
    
    class PostgreSQLRefreshTokenRepository {
        -jdbcTemplate: JdbcTemplate
        -tableName: String
        +saveToken(refreshToken: RefreshToken): RefreshToken
        +findByTokenRaw(token: String): Optional<RefreshToken>
        +deleteExpiredTokens(): void
        +revokeAllUserTokens(userEmail: String): void
        +count(): long
        -insert(token: RefreshToken): RefreshToken
        -update(token: RefreshToken): RefreshToken
        -mapRowToRefreshToken(rs: ResultSet): RefreshToken
    }
    
    UserJpaRepository .up.|> UserRepository
    UserJpaRepository .up.|> JpaRepository
    DefaultUserJpaRepository .up.|> UserJpaRepository
    UserPostgreSQLRepository .up.|> UserRepository
    JpaRefreshTokenRepository .up.|> RefreshTokenRepository
    JpaRefreshTokenRepository .up.|> JpaRepository
    DefaultJpaRefreshTokenRepository .up.|> JpaRefreshTokenRepository
    PostgreSQLRefreshTokenRepository .up.|> RefreshTokenRepository
}

package "Controller Layer" <<Rectangle>> {
    
    class AuthController {
        -jwtService: JwtService
        -authenticationManager: AuthenticationManager
        -refreshTokenService: RefreshTokenService<U, ID>
        -blocklist: TokenBlocklist
        +login(request: LoginRequestDTO, response: HttpServletResponse): ResponseEntity
        +refresh(refreshTokenCookie: String, response: HttpServletResponse): ResponseEntity
        +logout(response: HttpServletResponse): ResponseEntity
        +revokeToken(token: String): ResponseEntity
        +getAuthenticatedUser(authentication: Authentication): ResponseEntity<AuthenticatedUserDTO>
    }
    
    class UserController {
        -userService: UserService<U, R, ID>
        -passwordEncoder: PasswordEncoder
        -passwordPolicyService: PasswordPolicyService
        +createUser(request: CreateUserRequestDTO): ResponseEntity<UserDTO>
        +getUserById(id: ID): ResponseEntity<UserDTO>
        +getUserByEmail(email: String): ResponseEntity<UserDTO>
        +updateUser(id: ID, request: CreateUserRequestDTO): ResponseEntity<UserDTO>
        +deleteUser(id: ID): ResponseEntity<Void>
    }
    
}

package "Factory Layer" <<Rectangle>> {
    
    interface "AuthUserFactory<R>" as AuthUserFactory {
        +createAuthUser(username: String, email: String, password: String, roles: Set<R>): AuthUser<R>
        +createAuthUser(email: String, password: String, roles: Set<R>): AuthUser<R>
        +createAuthUser(email: String, password: String, role: R): AuthUser<R>
    }
    
    interface "UserFactory<U, R, ID>" as UserFactory {
        +createUser(username: String, email: String, password: String, roles: Set<R>): U
        +createUser(email: String, password: String, roles: Set<R>): U
        +createUser(email: String, password: String, role: R): U
    }
    
    class DefaultUserFactory {
        +createUser(username: String, email: String, password: String, roles: Set<Role>): DefaultUser
        +createUser(email: String, password: String, roles: Set<Role>): DefaultUser
        +createUser(email: String, password: String, role: Role): DefaultUser
    }
    
    DefaultUserFactory .up.|> UserFactory
    DefaultUserFactory .up.|> AuthUserFactory
}

package "Helper Classes" <<Rectangle>> {
    
    ' PostgreSQL Helper Classes
    interface "UserRowMapper<U>" as UserRowMapper {
        +mapRow(rs: ResultSet, rowNum: int): U
    }
    
    interface "UserSqlParameterMapper<U>" as UserSqlParameterMapper {
        +mapToSqlParameterSource(user: U): SqlParameterSource
    }
    
    interface "IdConverter<ID>" as IdConverter {
        +convert(id: Object): ID
        +convertToString(id: ID): String
    }
    
    class UUIDConverter {
        +convert(id: Object): UUID
        +convertToString(id: UUID): String
    }
    
    UUIDConverter .up.|> IdConverter
}

package "DTO Layer" <<Rectangle>> {
    
    class LoginRequestDTO {
        -email: String
        -password: String
    }
    
    class CreateUserRequestDTO {
        -username: String
        -email: String
        -password: String
    }
    
    class UserDTO {
        -id: UUID
        -username: String
        -email: String
    }
    
    class TokenDTO {
        -token: String
    }
    
    ' NEW: Updated for refresh tokens
    class TokenResponse {
        -accessToken: String
        -refreshToken: String
        +TokenResponse(accessToken: String, refreshToken: String)
    }
    
    class AuthenticatedUserDTO {
        -name: String
        -roles: List<String>
        +AuthenticatedUserDTO(name: String, authorities: Collection<GrantedAuthority>)
    }
    
    class UserDTOMapper {
        +{static} toDTO(user: AuthUser<?>): UserDTO
    }
    
    AuthenticatedUserDTO .up.|> AuthenticatedUser
}

package "Security Configuration" <<Rectangle>> {
    
    class SecurityConfig {
        -jwtAuthFilter: JwtAuthFilter
        -userDetailsService: UserDetailsService
        +filterChain(http: HttpSecurity): SecurityFilterChain
        +authenticationManager(config: AuthenticationConfiguration): AuthenticationManager
        +passwordEncoder(): PasswordEncoder
    }
    
    class JwtAuthFilter {
        -jwtService: JwtService
        -tokenBlocklist: TokenBlocklist
        +doFilterInternal(request: HttpServletRequest, response: HttpServletResponse, filterChain: FilterChain): void
        ' Extracts JWT from access_token cookie
    }
    
    JwtAuthFilter .up.|> OncePerRequestFilter
}

package "Auto Configuration" <<Rectangle>> {
    
    class AuthAutoConfiguration {
        +jwtService(): JwtService
        +passwordPolicyService(authProperties: AuthProperties): PasswordPolicyService
        +userService(userRepository: UserRepository, passwordPolicy: PasswordPolicyService): UserService<User, Long>
        +refreshTokenService(refreshTokenRepository: RefreshTokenRepository, userService: UserService, authProperties: AuthProperties): RefreshTokenService
        +refreshTokenCleanupService(refreshTokenRepository: RefreshTokenRepository, authProperties: AuthProperties): RefreshTokenCleanupService
        +userDetailsService(userRepository: UserRepository): UserDetailsServiceImpl
        +jwtAuthFilter(jwtService: JwtService): JwtAuthFilter
        +authController(jwtService: JwtService, authManager: AuthenticationManager, refreshTokenService: RefreshTokenService): AuthController
        +userController(userService: UserService<User, Long>, passwordEncoder: PasswordEncoder, passwordPolicyService: PasswordPolicyService): UserController
        +postgresqlRefreshTokenRepository(dataSource: DataSource, authProperties: AuthProperties): PostgreSQLRefreshTokenRepository
    }
    
    class AuthProperties {
        -enabled: boolean
        -jwt: Jwt
        -refreshTokens: RefreshTokens
        -passwordPolicy: PasswordPolicy
        -controllers: Controllers
    }
    
    class "AuthProperties.Jwt" as JwtProps {
        -secret: String
        -accessTokenExpiration: long
        -refreshTokenExpiration: long
    }
    
    ' NEW: Refresh Token Configuration
    class "AuthProperties.RefreshTokens" as RefreshTokensProps {
        -enabled: boolean
        -maxTokensPerUser: int
        -rotateOnRefresh: boolean
        -cleanupInterval: long
        -autoCleanup: boolean
        -repository: Repository
    }
    
    class "AuthProperties.RefreshTokens.Repository" as RepositoryProps {
        -type: RefreshTokenRepositoryType
        -database: Database
    }
    
    class "AuthProperties.PasswordPolicy" as PasswordPolicyProps {
        -minLength: int
        -maxLength: int
        -requireUppercase: boolean
        -requireLowercase: boolean
        -requireDigits: boolean
        -requireSpecialChars: boolean
        -specialCharacters: String
        -preventCommonPasswords: boolean
        -commonPasswordsFilePath: String
    }
    
    class "AuthProperties.Controllers" as ControllersProps {
        -auth: Controller
        -user: Controller
    }
    
    enum RefreshTokenRepositoryType {
        JPA
        POSTGRESQL
    }
    
    AuthProperties *-- JwtProps
    AuthProperties *-- RefreshTokensProps
    AuthProperties *-- PasswordPolicyProps
    AuthProperties *-- ControllersProps
    RefreshTokensProps *-- RepositoryProps
    RepositoryProps --> RefreshTokenRepositoryType

}

package "Exception Handling" <<Rectangle>> {
    
    class GlobalExceptionHandler {
        +handleDuplicateResourceException(ex: DuplicateResourceException): ResponseEntity<ErrorResponse>
        +handleResourceNotFoundException(ex: ResourceNotFoundException): ResponseEntity<ErrorResponse>
        +handleTokenExpiredException(ex: TokenExpiredException): ResponseEntity<ErrorResponse>
        +handleValidationException(ex: MethodArgumentNotValidException): ResponseEntity<ErrorResponse>
        +handleGenericException(ex: Exception): ResponseEntity<ErrorResponse>
    }
    
    class DuplicateResourceException {
        +DuplicateResourceException(message: String)
    }
    
    class ResourceNotFoundException {
        +ResourceNotFoundException(message: String)
    }
    
    ' NEW: Token Exception
    class TokenExpiredException {
        +TokenExpiredException(message: String)
    }
    
    class ErrorResponse {
        -message: String
        -timestamp: LocalDateTime
    }
}

package "Service Layer" <<Rectangle>> {

    class UserServiceImpl {
        -userRepository: UserRepository
        +createUser(user: User): User
        +getUserByEmail(email: String): User
        +emailExists(email: String): boolean
        +usernameExists(username: String): boolean
        +updateUser(id: Long, user: User): User
        +deleteUser(id: Long): void
        +getAllUsers(): List<User>
    }

    class JwtServiceImpl {
        -secret: String
        -accessTokenExpiration: long
        -key: Key
        +generateAccessToken(subject: String, authorities: Collection<GrantedAuthority>): String
        +isTokenValid(token: String, email: String): boolean
        -createToken(claims: Map<String, Object>, subject: String): String
        -getKey(): Key
    }

    class PasswordPolicy {
        -authProperties: AuthProperties
        -minLength: int
        -maxLength: int
        -requireUpperCase: boolean
        -requireLowerCase: boolean
        -requireDigit: boolean
        -requireSpecialChar: boolean
        -specialCharacters: String
        -preventCommonPasswords: boolean
        -commonPasswords: Set<String>
        +PasswordPolicy(authProperties: AuthProperties)
        +validatePassword(password: String): boolean
        +generateSecurePassword(): String
        -loadCommonPasswords(): Set<String>
        -validateLength(password: String): void
        -validateCharacterRequirements(password: String): void
        -validateCommonPassword(password: String): void
    }

    class UserDetailsServiceImpl {
        -userService: UserService<User, Long>
        +loadUserByUsername(email: String): UserDetails
    }

    ' NEW: Refresh Token Service Implementation
    class RefreshTokenServiceImpl {
        -refreshTokenRepository: RefreshTokenRepository
        -userService: UserService
        -authProperties: AuthProperties
        +createRefreshToken(user: AuthUser): RefreshToken
        +findByToken(token: String): Optional<RefreshToken>
        +verifyExpiration(token: RefreshToken): RefreshToken
        +deleteByToken(token: String): void
        +deleteAllByUserEmail(userEmail: String): void
    }

    ' NEW: Refresh Token Cleanup Service
    class RefreshTokenCleanupService {
        -refreshTokenRepository: RefreshTokenRepository
        -authProperties: AuthProperties
        +cleanupExpiredTokens(): void
        +cleanupExpiredTokensForUser(userEmail: String): void
    }

    UserServiceImpl .up.|> UserService
    JwtServiceImpl .up.|> JwtService
    PasswordPolicy .up.|> PasswordPolicyService
    UserDetailsServiceImpl .up.|> UserDetailsService
    RefreshTokenServiceImpl .up.|> RefreshTokenService
    UserServiceImpl --> PasswordPolicyService : validates passwords
    RefreshTokenServiceImpl --> UserService : uses
    RefreshTokenCleanupService --> RefreshTokenRepository : cleans up
}


' Relationships
UserServiceImpl --> UserRepository : uses
UserDetailsServiceImpl --> UserService : uses
AuthController --> JwtService : uses
AuthController --> RefreshTokenService : uses
UserController --> UserService : uses
UserController --> PasswordPolicyService : uses
JwtAuthFilter --> JwtService : uses
SecurityConfig --> JwtAuthFilter : configures
UserDTOMapper --> User : maps
RefreshTokenCleanupService --> RefreshTokenRepository : uses
RefreshTokenServiceImpl --> RefreshTokenRepository : uses

' Notes with better styling
note right of AuthUser #E8F4FD
  **Enhanced Generic Interface (v3.0.0)**
  Type-safe role generics with
  improved polymorphic behavior
  and better decoupling
end note

note right of User #E8F4FD
  **UserDetails Implementation (v3.0.0)**
  UUID primary keys with enhanced
  Spring Security integration
end note

note bottom of Username #E8F4FD
  **Value Objects**
  Built-in validation and
  immutability guarantees
end note

note bottom of RefreshToken #E8F4FD
  **🆕 Refresh Token (v1.2.0)**
  Secure token rotation with
  configurable expiration
end note

note bottom of RefreshTokenRepository #E8F4FD
  **🆕 Multi-Repository Support (v1.2.0)**
  JPA and PostgreSQL implementations
  with resolved interface conflicts
end note

note bottom of UserServiceImpl #E8F4FD
  **Enhanced Generic Service (v3.0.0)**
  Three-type generics <U,R,ID>
  with UUID support and improved
  type safety
end note

note top of AuthAutoConfiguration #E8F4FD
  **Auto-Configuration**
  Automatically configures beans
  when starter is included
end note



note right of RefreshTokenServiceImpl #E8F4FD
  **🆕 Refresh Token Service (v1.2.0)**
  Manages token lifecycle with
  automatic cleanup and rotation
end note

note right of UserPostgreSQLRepository #E8F4FD
  **🆕 PostgreSQL Native Repository (v3.0.0)**
  Direct JDBC implementation
  with enhanced performance and
  custom SQL queries
end note

note right of UserFactory #E8F4FD
  **🆕 Factory Pattern (v3.0.0)**
  Decoupled user creation with
  type-safe generics for enhanced
  architecture flexibility
end note

note right of UUIDConverter #E8F4FD
  **🆕 Helper Classes (v3.0.0)**
  Type converters and mappers
  for PostgreSQL integration
  and better type safety
end note

note right of PostgreSQLRefreshTokenRepository #E8F4FD
  **🆕 PostgreSQL Repository (v1.2.0)**
  Native queries with proper
  timestamp handling
end note

' Blocklist and Rate Limiter interfaces and implementations
package "Blocklist & Rate Limiter" <<Rectangle>> {
    interface TokenBlocklist {
        +revoke(token: String): void
        +isRevoked(token: String): boolean
    }
    class InMemoryTokenBlocklist {
        +revoke(token: String): void
        +isRevoked(token: String): boolean
    }
    class RedisTokenBlockList {
        +revoke(token: String): void
        +isRevoked(token: String): boolean
    }
    interface RateLimiter {
        +isEnabled(): boolean
        +allowRequest(key: String): boolean
    }
    class InMemoryRateLimiter {
        +isEnabled(): boolean
        +allowRequest(key: String): boolean
    }
    class RedisRateLimiter {
        +isEnabled(): boolean
        +allowRequest(key: String): boolean
    }
    TokenBlocklist <|.. InMemoryTokenBlocklist
    TokenBlocklist <|.. RedisTokenBlockList
    RateLimiter <|.. InMemoryRateLimiter
    RateLimiter <|.. RedisRateLimiter
}





' Add notes for cookie-based token handling and security
note right of AuthController #E8F4FD
  **Cookie-based Auth (v2.0.0)**
  All tokens are set and read via
  secure, HttpOnly cookies only.
  Includes /api/auth/revoke endpoint
  for admin token revocation.
end note

note right of TokenBlocklist #E8F4FD
  **Blocklist (v2.0.0)**
  Supports in-memory and Redis
  for token revocation.
end note

note right of RateLimiter #E8F4FD
  **Rate Limiting (v2.0.0)**
  In-memory and Redis implementations
  for per-user/IP request limiting.
end note

note right of JwtAuthFilter #E8F4FD
  **JWT via Cookie**
  Extracts JWT from access_token cookie
  for all protected endpoints.
end note

@enduml