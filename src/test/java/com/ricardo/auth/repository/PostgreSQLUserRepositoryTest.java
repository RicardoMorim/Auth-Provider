package com.ricardo.auth.repository;

import com.ricardo.auth.autoconfig.AuthAutoConfiguration;
import com.ricardo.auth.config.SecurityConfig;
import com.ricardo.auth.core.PasswordPolicyService;
import com.ricardo.auth.domain.user.*;
import com.ricardo.auth.helper.*;
import com.ricardo.auth.repository.user.UserPostgreSQLRepository;
import com.ricardo.auth.repository.user.UserRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import org.springframework.orm.ObjectOptimisticLockingFailureException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.TestPropertySource;
import org.springframework.transaction.annotation.Transactional;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.time.Instant;
import java.util.*;
import java.util.concurrent.CountDownLatch;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

/**
 * Tests for PostgreSQL user repository implementation.
 */
@SpringBootTest
@Testcontainers
@ActiveProfiles("test")
@TestPropertySource(properties = {
        "ricardo.auth.repository.type=POSTGRESQL",
        "ricardo.auth.repository.database.url=jdbc:postgresql://localhost:5432/AuthLibraryTest",
        "ricardo.auth.repository.database.username=postgres",
        "ricardo.auth.repository.database.password=8080",
        "ricardo.auth.repository.database.driver-class-name=org.postgresql.Driver",
        "spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration"
})
class PostgreSQLUserRepositoryTest {


    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private PasswordPolicyService passwordPolicyService;

    @Autowired
    private IdConverter<UUID> idConverter;

    @Autowired
    private UserRepository<User, AppRole, UUID> repository;

    @Autowired
    private UserRowMapper<User, AppRole, UUID> userRowMapper;

    @Autowired
    private UserSqlParameterMapper<User> userSqlParameterMapper;

    @Autowired
    private RoleMapper<AppRole> roleMapper;

    /**
     * Sets up.
     */
    @BeforeEach
    void setUp() {
        // Clean up any existing data
        repository.deleteAll();
    }

    /**
     * Should use postgre sql implementation.
     */
    @Test
    @DisplayName("Should use PostgreSQL implementation")
    void shouldUsePostgreSQLImplementation() {
        assertThat(repository).isInstanceOf(UserPostgreSQLRepository.class);
    }

    /**
     * Should create new user with auto generated id and version.
     */
    @Test
    @DisplayName("Should create new user with auto-generated ID and version")
    void shouldCreateNewUserWithAutoGeneratedIdAndVersion() {
        // Arrange
        User user = createTestUser("testuser", "test@example.com");

        // Act
        User savedUser = repository.saveUser(user);

        // Assert
        assertThat(savedUser.getId()).isNotNull();
        assertThat(savedUser.getVersion()).isEqualTo(0L);
        assertThat(savedUser.getUsername()).isEqualTo("testuser");
        assertThat(savedUser.getEmail()).isEqualTo("test@example.com");
    }

    /**
     * Should find user by email.
     */
    @Test
    @DisplayName("Should find user by email")
    void shouldFindUserByEmail() {
        // Arrange
        User user = createTestUser("testuser", "test@example.com");
        repository.saveUser(user);

        // Act
        Optional<User> found = repository.findByEmail("test@example.com");

        // Assert
        assertThat(found).isPresent();
        assertThat(found.get().getUsername()).isEqualTo("testuser");
        assertThat(found.get().getEmail()).isEqualTo("test@example.com");
    }

    /**
     * Should find user by username.
     */
    @Test
    @DisplayName("Should find user by username")
    void shouldFindUserByUsername() {
        // Arrange
        User user = createTestUser("testuser", "test@example.com");
        repository.saveUser(user);

        // Act
        Optional<User> found = repository.findByUsername("testuser");

        // Assert
        assertThat(found).isPresent();
        assertThat(found.get().getUsername()).isEqualTo("testuser");
        assertThat(found.get().getEmail()).isEqualTo("test@example.com");
    }

    /**
     * Should find user by id.
     */
    @Test
    @DisplayName("Should find user by ID")
    void shouldFindUserById() {
        // Arrange
        User user = createTestUser("testuser", "test@example.com");
        User savedUser = repository.saveUser(user);

        // Act
        Optional<User> found = repository.findById((UUID) savedUser.getId());

        // Assert
        assertThat(found).isPresent();
        assertThat(found.get().getId()).isEqualTo(savedUser.getId());
        assertThat(found.get().getUsername()).isEqualTo("testuser");
    }

    /**
     * Should return empty when user not found.
     */
    @Test
    @DisplayName("Should return empty when user not found")
    void shouldReturnEmptyWhenUserNotFound() {
        // Act & Assert
        assertThat(repository.findByEmail("nonexistent@example.com")).isEmpty();
        assertThat(repository.findByUsername("nonexistent")).isEmpty();
        assertThat(repository.findById(UUID.randomUUID())).isEmpty();
    }

    /**
     * Should check if user exists by email.
     */
    @Test
    @DisplayName("Should check if user exists by email")
    void shouldCheckIfUserExistsByEmail() {
        // Arrange
        User user = createTestUser("testuser", "test@example.com");
        repository.saveUser(user);

        // Act & Assert
        assertThat(repository.existsByEmail("test@example.com")).isTrue();
        assertThat(repository.existsByEmail("nonexistent@example.com")).isFalse();
    }

    /**
     * Should check if user exists by username.
     */
    @Test
    @DisplayName("Should check if user exists by username")
    void shouldCheckIfUserExistsByUsername() {
        // Arrange
        User user = createTestUser("testuser", "test@example.com");
        repository.saveUser(user);

        // Act & Assert
        assertThat(repository.existsByUsername("testuser")).isTrue();
        assertThat(repository.existsByUsername("nonexistent")).isFalse();
    }

    /**
     * Should check if user exists by id.
     */
    @Test
    @DisplayName("Should check if user exists by ID")
    void shouldCheckIfUserExistsById() {
        // Arrange
        User user = createTestUser("testuser", "test@example.com");
        User savedUser = repository.saveUser(user);

        // Act & Assert
        assertThat(repository.existsById((UUID) savedUser.getId())).isTrue();
        assertThat(repository.existsById(UUID.randomUUID())).isFalse();
    }

    /**
     * Should update existing user with optimistic locking.
     */
    @Test
    @DisplayName("Should update existing user with optimistic locking")
    void shouldUpdateExistingUserWithOptimisticLocking() {
        // Arrange
        User user = createTestUser("testuser", "test@example.com");
        User savedUser = repository.saveUser(user);

        // Act - Update user
        savedUser.setUsername("updateduser");
        savedUser.setEmail("updated@example.com");
        User updatedUser = repository.saveUser(savedUser);

        // Assert
        assertThat(updatedUser.getId()).isEqualTo(savedUser.getId());
        assertThat(updatedUser.getVersion()).isEqualTo(1L); // Version incremented
        assertThat(updatedUser.getUsername()).isEqualTo("updateduser");
        assertThat(updatedUser.getEmail()).isEqualTo("updated@example.com");
        assertThat(updatedUser.getUpdatedAt()).isNotNull();
    }

    /**
     * Should throw exception on optimistic locking failure.
     */
    @Test
    @DisplayName("Should throw exception on optimistic locking failure")
    void shouldThrowExceptionOnOptimisticLockingFailure() {
        // Arrange
        User user = createTestUser("testuser", "test@example.com");
        User savedUser = repository.saveUser(user);

        // Simulate concurrent modification by manually setting wrong version
        savedUser.setVersion(999L);
        savedUser.setUsername("updateduser");

        // Act & Assert
        assertThatThrownBy(() -> repository.saveUser(savedUser))
                .isInstanceOf(ObjectOptimisticLockingFailureException.class)
                .hasMessageContaining("was not found or has been modified");
    }

    /**
     * Should save user with roles.
     */
    @Test
    @DisplayName("Should save user with roles")
    void shouldSaveUserWithRoles() {
        // Arrange
        User user = createTestUser("adminuser", "admin@example.com");
        user.addRole(AppRole.ADMIN);
        user.addRole(AppRole.USER);

        // Act
        User savedUser = repository.saveUser(user);

        // Assert
        assertThat(savedUser.getRoles()).hasSize(2);
        assertThat(savedUser.getRoles()).contains(AppRole.ADMIN, AppRole.USER);

        // Verify by fetching from database
        Optional<User> found = repository.findById((UUID) savedUser.getId());
        assertThat(found).isPresent();
        assertThat(found.get().getRoles()).hasSize(2);
        assertThat(found.get().getRoles()).contains(AppRole.ADMIN, AppRole.USER);
    }

    /**
     * Should update user roles.
     */
    @Test
    @DisplayName("Should update user roles")
    void shouldUpdateUserRoles() {
        // Arrange
        User user = createTestUser("roleuser", "role@example.com");
        user.addRole(AppRole.USER);
        User savedUser = repository.saveUser(user);

        // Act - Update roles
        savedUser.getRoles().clear();
        savedUser.addRole(AppRole.ADMIN);
        User updatedUser = repository.saveUser(savedUser);

        // Assert
        assertThat(updatedUser.getRoles()).hasSize(1);
        assertThat(updatedUser.getRoles()).contains(AppRole.ADMIN);

        // Verify by fetching from database
        Optional<User> found = repository.findById((UUID) savedUser.getId());
        assertThat(found).isPresent();
        assertThat(found.get().getRoles()).hasSize(1);
        assertThat(found.get().getRoles()).contains(AppRole.ADMIN);
    }

    /**
     * Should save multiple users.
     */
    @Test
    @DisplayName("Should save multiple users")
    void shouldSaveMultipleUsers() {
        // Arrange
        List<User> users = Arrays.asList(
                createTestUser("user1", "user1@example.com"),
                createTestUser("user2", "user2@example.com"),
                createTestUser("user3", "user3@example.com")
        );

        // Act
        List<User> savedUsers = repository.saveAll(users);

        // Assert
        assertThat(savedUsers).hasSize(3);
        savedUsers.forEach(user -> {
            assertThat(user.getId()).isNotNull();
            assertThat(user.getVersion()).isEqualTo(0L);
        });
    }

    /**
     * Should find all users.
     */
    @Test
    @DisplayName("Should find all users")
    void shouldFindAllUsers() {
        // Arrange
        repository.saveUser(createTestUser("user1", "user1@example.com"));
        repository.saveUser(createTestUser("user2", "user2@example.com"));
        repository.saveUser(createTestUser("user3", "user3@example.com"));

        // Act
        List<User> allUsers = repository.findAll();

        // Assert
        assertThat(allUsers).hasSize(3);
        assertThat(allUsers).extracting("username")
                .containsExactlyInAnyOrder("user1", "user2", "user3");
    }

    /**
     * Should find users by ids.
     */
    @Test
    @DisplayName("Should find users by IDs")
    void shouldFindUsersByIds() {
        // Arrange
        User user1 = repository.saveUser(createTestUser("user1", "user1@example.com"));
        User user2 = repository.saveUser(createTestUser("user2", "user2@example.com"));
        User user3 = repository.saveUser(createTestUser("user3", "user3@example.com"));

        List<UUID> ids = Arrays.asList((UUID) user1.getId(), (UUID) user3.getId());

        // Act
        List<User> foundUsers = repository.findAllById(ids);

        // Assert
        assertThat(foundUsers).hasSize(2);
        assertThat(foundUsers).extracting("username")
                .containsExactlyInAnyOrder("user1", "user3");
    }

    /**
     * Should count users.
     */
    @Test
    @DisplayName("Should count users")
    void shouldCountUsers() {
        // Arrange
        repository.saveUser(createTestUser("user1", "user1@example.com"));
        repository.saveUser(createTestUser("user2", "user2@example.com"));

        // Act
        long count = repository.count();

        // Assert
        assertThat(count).isEqualTo(2L);
    }

    /**
     * Should delete user by id.
     */
    @Test
    @DisplayName("Should delete user by ID")
    void shouldDeleteUserById() {
        // Arrange
        User user = createTestUser("deleteuser", "delete@example.com");
        User savedUser = repository.saveUser(user);

        // Act
        repository.deleteById((UUID) savedUser.getId());

        // Assert
        assertThat(repository.findById((UUID) savedUser.getId())).isEmpty();
        assertThat(repository.existsById((UUID) savedUser.getId())).isFalse();
    }

    /**
     * Should delete user entity.
     */
    @Test
    @DisplayName("Should delete user entity")
    void shouldDeleteUserEntity() {
        // Arrange
        User user = createTestUser("deleteuser", "delete@example.com");
        User savedUser = repository.saveUser(user);

        // Act
        repository.delete(savedUser);

        // Assert
        assertThat(repository.findById((UUID) savedUser.getId())).isEmpty();
    }

    /**
     * Should delete users by ids.
     */
    @Test
    @DisplayName("Should delete users by IDs")
    void shouldDeleteUsersByIds() {
        // Arrange
        User user1 = repository.saveUser(createTestUser("user1", "user1@example.com"));
        User user2 = repository.saveUser(createTestUser("user2", "user2@example.com"));
        User user3 = repository.saveUser(createTestUser("user3", "user3@example.com"));

        List<UUID> idsToDelete = Arrays.asList((UUID) user1.getId(), (UUID) user3.getId());

        // Act
        repository.deleteAllById(idsToDelete);

        // Assert
        assertThat(repository.existsById((UUID) user1.getId())).isFalse();
        assertThat(repository.existsById((UUID) user2.getId())).isTrue();
        assertThat(repository.existsById((UUID) user3.getId())).isFalse();
    }

    /**
     * Should delete user entities.
     */
    @Test
    @DisplayName("Should delete user entities")
    void shouldDeleteUserEntities() {
        // Arrange
        User user1 = repository.saveUser(createTestUser("user1", "user1@example.com"));
        User user2 = repository.saveUser(createTestUser("user2", "user2@example.com"));

        // Act
        repository.deleteAll(Arrays.asList(user1, user2));

        // Assert
        assertThat(repository.count()).isEqualTo(0L);
    }

    /**
     * Should delete all users.
     */
    @Test
    @DisplayName("Should delete all users")
    void shouldDeleteAllUsers() {
        // Arrange
        repository.saveUser(createTestUser("user1", "user1@example.com"));
        repository.saveUser(createTestUser("user2", "user2@example.com"));

        // Act
        repository.deleteAll();

        // Assert
        assertThat(repository.count()).isEqualTo(0L);
        assertThat(repository.findAll()).isEmpty();
    }

    /**
     * Should handle postgre sql timestamp operations.
     */
    @Test
    @DisplayName("Should handle PostgreSQL timestamp operations correctly")
    void shouldHandlePostgreSQLTimestampOperations() throws InterruptedException {
        // Arrange
        User user = createTestUser("timestampuser", "timestamp@example.com");

        // Act
        User savedUser = repository.saveUser(user);

        // Assert
        assertThat(savedUser.getCreatedAt()).isNotNull();
        assertThat(savedUser.getUpdatedAt()).isNotNull();
        assertThat(savedUser.getCreatedAt()).isBeforeOrEqualTo(Instant.now());
        assertThat(savedUser.getUpdatedAt()).isBeforeOrEqualTo(Instant.now());

        Thread.sleep(100);

        // Test update timestamp
        Instant originalUpdatedAt = savedUser.getUpdatedAt();
        savedUser.setUsername("updated");

        User updatedUser = repository.saveUser(savedUser);
        assertThat(updatedUser.getUpdatedAt()).isAfter(originalUpdatedAt);
    }

    /**
     * Should handle concurrent user operations.
     *
     * @throws InterruptedException the interrupted exception
     */
    @Test
    @DisplayName("Should handle concurrent user operations")
    void shouldHandleConcurrentUserOperations() throws InterruptedException {
        // Arrange
        int threadCount = 10;
        CountDownLatch latch = new CountDownLatch(threadCount);
        List<User> createdUsers = Collections.synchronizedList(new ArrayList<>());

        // Act - Create users concurrently
        for (int i = 0; i < threadCount; i++) {
            final int userIndex = i;
            new Thread(() -> {
                try {
                    User user = createTestUser("user" + userIndex, "user" + userIndex + "@example.com");
                    User savedUser = repository.saveUser(user);
                    createdUsers.add(savedUser);
                } finally {
                    latch.countDown();
                }
            }).start();
        }

        latch.await();

        // Assert
        assertThat(createdUsers).hasSize(threadCount);
        assertThat(repository.count()).isEqualTo(threadCount);

        // Verify all users have unique IDs
        Set<Object> uniqueIds = new HashSet<>();
        createdUsers.forEach(user -> uniqueIds.add(user.getId()));
        assertThat(uniqueIds).hasSize(threadCount);
    }

    /**
     * Should handle large username and email values.
     */
    @Test
    @DisplayName("Should handle large username and email values")
    void shouldHandleLargeUsernameAndEmailValues() {
        // Arrange - Create user with large values (but within reasonable database limits)
        String largeUsername = "a".repeat(20);
        String largeEmail = "a".repeat(90) + "@example.com";

        User user = createTestUser(largeUsername, largeEmail);

        // Act
        User savedUser = repository.saveUser(user);
        Optional<User> foundUser = repository.findByUsername(largeUsername);

        // Assert
        assertThat(savedUser.getUsername()).isEqualTo(largeUsername);
        assertThat(savedUser.getEmail()).isEqualTo(largeEmail);
        assertThat(foundUser).isPresent();
        assertThat(foundUser.get().getUsername()).isEqualTo(largeUsername);
    }

    /**
     * Should handle empty roles correctly.
     */
    @Test
    @DisplayName("Should handle empty roles correctly")
    void shouldHandleEmptyRolesCorrectly() {
        // Arrange
        User user = createTestUser("noroleuser", "norole@example.com");
        // Don't add any roles

        // Act
        User savedUser = repository.saveUser(user);

        // Assert
        assertThat(savedUser.getRoles()).isEmpty();

        // Verify by fetching from database
        Optional<User> found = repository.findById((UUID) savedUser.getId());
        assertThat(found).isPresent();
        assertThat(found.get().getRoles()).isEmpty();
    }

    /**
     * Should maintain referential integrity when deleting users with roles.
     */
    @Test
    @DisplayName("Should maintain referential integrity when deleting users with roles")
    void shouldMaintainReferentialIntegrityWhenDeletingUsersWithRoles() {
        // Arrange
        User user = createTestUser("roleuser", "role@example.com");
        user.addRole(AppRole.ADMIN);
        user.addRole(AppRole.USER);
        User savedUser = repository.saveUser(user);

        // Act
        repository.deleteById((UUID) savedUser.getId());

        // Assert
        assertThat(repository.findById((UUID) savedUser.getId())).isEmpty();
        // User roles should be deleted automatically due to CASCADE
    }

    /**
     * Should handle batch operations efficiently.
     */
    @Test
    @DisplayName("Should handle batch operations efficiently")
    void shouldHandleBatchOperationsEfficiently() {
        // Arrange
        List<User> users = new ArrayList<>();
        for (int i = 0; i < 50; i++) {
            users.add(createTestUser("batchuser" + i, "batch" + i + "@example.com"));
        }

        // Act
        long startTime = System.currentTimeMillis();
        List<User> savedUsers = repository.saveAll(users);
        long endTime = System.currentTimeMillis();

        // Assert
        assertThat(savedUsers).hasSize(50);
        assertThat(repository.count()).isEqualTo(50L);

        // Verify performance (should complete in reasonable time)
        long duration = endTime - startTime;
        assertThat(duration).isLessThan(5000L); // Should complete within 5 seconds
    }

    /**
     * Should handle null parameters gracefully.
     */
    @Test
    @DisplayName("Should handle null parameters gracefully")
    void shouldHandleNullParametersGracefully() {
        // Act & Assert
        assertThat(repository.findByEmail(null)).isEmpty();
        assertThat(repository.findByUsername(null)).isEmpty();
        assertThat(repository.existsByEmail(null)).isFalse();
        assertThat(repository.existsByUsername(null)).isFalse();
    }

    /**
     * Should handle empty parameters gracefully.
     */
    @Test
    @DisplayName("Should handle empty parameters gracefully")
    void shouldHandleEmptyParametersGracefully() {
        // Act & Assert
        assertThat(repository.findByEmail("")).isEmpty();
        assertThat(repository.findByUsername("")).isEmpty();
        assertThat(repository.existsByEmail("")).isFalse();
        assertThat(repository.existsByUsername("")).isFalse();
    }

    /**
     * Should preserve creation timestamp on update.
     */
    @Test
    @DisplayName("Should preserve creation timestamp on update")
    void shouldPreserveCreationTimestampOnUpdate() throws InterruptedException {
        // Arrange
        User user = createTestUser("timestamptest", "timestamp@example.com");
        User savedUser = repository.saveUser(user);
        Instant originalCreatedAt = savedUser.getCreatedAt();
        Thread.sleep(100);
        // Act - Update user
        savedUser.setUsername("updated");
        User updatedUser = repository.saveUser(savedUser);

        // Assert
        assertThat(updatedUser.getCreatedAt()).isEqualTo(originalCreatedAt);
        assertThat(updatedUser.getUpdatedAt()).isAfter(originalCreatedAt);
    }

    // Helper method to create test users
    private User createTestUser(String username, String email) {
        return new User(
                Username.valueOf(username),
                Email.valueOf(email),
                Password.valueOf("TestPassword@123", passwordEncoder, passwordPolicyService)
        );
    }

    // Helper method to create test user with unique suffix
    private User createTestUserWithSuffix(String baseUsername, String baseEmail, String suffix) {
        return createTestUser(baseUsername + suffix, baseEmail.replace("@", suffix + "@"));
    }
}